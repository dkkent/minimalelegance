import { 
  users, 
  type User, 
  type InsertUser, 
  questions, 
  type Question, 
  type InsertQuestion,
  responses, 
  type Response, 
  type InsertResponse,
  loveslices, 
  type Loveslice, 
  type InsertLoveslice,
  activeQuestions, 
  type ActiveQuestion, 
  type InsertActiveQuestion 
} from "@shared/schema";
import { db } from "./db";
import { and, eq } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";
import { sql } from "drizzle-orm";

// PostgreSQL session store
const PostgresSessionStore = connectPg(session);

export interface IStorage {
  // User related methods
  getUser(id: number): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  linkPartner(userId: number, partnerId: number): Promise<boolean>;
  getUserByInviteCode(inviteCode: string): Promise<User | undefined>;
  
  // Question related methods
  getQuestions(): Promise<Question[]>;
  getQuestion(id: number): Promise<Question | undefined>;
  createQuestion(question: InsertQuestion): Promise<Question>;
  getQuestionsByTheme(theme: string): Promise<Question[]>;
  
  // Active question related methods
  assignQuestionToUser(data: InsertActiveQuestion): Promise<ActiveQuestion>;
  getActiveQuestionForUser(userId: number): Promise<{ activeQuestion: ActiveQuestion, question: Question } | undefined>;
  markActiveQuestionAsAnswered(id: number): Promise<ActiveQuestion | undefined>;
  
  // Response related methods
  createResponse(response: InsertResponse): Promise<Response>;
  getResponsesByQuestionAndUser(questionId: number, userId: number): Promise<Response | undefined>;
  
  // Loveslice related methods
  createLoveslice(loveslice: InsertLoveslice): Promise<Loveslice>;
  getLoveslices(userId: number): Promise<any[]>;
  getLovesliceById(id: number): Promise<any | undefined>;
  updateLovesliceNote(id: number, note: string): Promise<Loveslice | undefined>;
  
  // Session store
  sessionStore: session.SessionStore;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.SessionStore;

  constructor() {
    this.sessionStore = new PostgresSessionStore({
      conObject: {
        connectionString: process.env.DATABASE_URL,
      },
      createTableIfMissing: true
    });

    // Seed questions (only run this once)
    this.seedQuestionsIfNeeded();
  }

  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    // Generate a unique invite code
    const inviteCode = Math.random().toString(36).substring(2, 10);
    
    const [user] = await db
      .insert(users)
      .values({ ...insertUser, inviteCode })
      .returning();
    
    return user;
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    const [user] = await db
      .update(users)
      .set(updates)
      .where(eq(users.id, id))
      .returning();
    
    return user;
  }

  async linkPartner(userId: number, partnerId: number): Promise<boolean> {
    try {
      // Update the user
      await db
        .update(users)
        .set({ partnerId, isIndividual: false })
        .where(eq(users.id, userId));
      
      // Update the partner
      await db
        .update(users)
        .set({ partnerId: userId, isIndividual: false })
        .where(eq(users.id, partnerId));
      
      return true;
    } catch (error) {
      console.error("Error linking partners:", error);
      return false;
    }
  }

  async getUserByInviteCode(inviteCode: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.inviteCode, inviteCode));
    return user;
  }

  async getQuestions(): Promise<Question[]> {
    return db.select().from(questions);
  }

  async getQuestion(id: number): Promise<Question | undefined> {
    const [question] = await db.select().from(questions).where(eq(questions.id, id));
    return question;
  }

  async createQuestion(question: InsertQuestion): Promise<Question> {
    const [newQuestion] = await db
      .insert(questions)
      .values(question)
      .returning();
    
    return newQuestion;
  }

  async getQuestionsByTheme(theme: string): Promise<Question[]> {
    return db.select().from(questions).where(eq(questions.theme, theme));
  }

  async assignQuestionToUser(data: InsertActiveQuestion): Promise<ActiveQuestion> {
    const [activeQuestion] = await db
      .insert(activeQuestions)
      .values(data)
      .returning();
    
    return activeQuestion;
  }

  async getActiveQuestionForUser(userId: number): Promise<{ activeQuestion: ActiveQuestion, question: Question } | undefined> {
    const result = await db
      .select({
        activeQuestion: activeQuestions,
        question: questions
      })
      .from(activeQuestions)
      .innerJoin(questions, eq(activeQuestions.questionId, questions.id))
      .where(and(
        eq(activeQuestions.userId, userId),
        eq(activeQuestions.isAnswered, false)
      ))
      .limit(1);
    
    if (result.length === 0) return undefined;
    
    return {
      activeQuestion: result[0].activeQuestion,
      question: result[0].question
    };
  }

  async markActiveQuestionAsAnswered(id: number): Promise<ActiveQuestion | undefined> {
    const [updatedActiveQuestion] = await db
      .update(activeQuestions)
      .set({ isAnswered: true })
      .where(eq(activeQuestions.id, id))
      .returning();
    
    return updatedActiveQuestion;
  }

  async createResponse(response: InsertResponse): Promise<Response> {
    const [newResponse] = await db
      .insert(responses)
      .values(response)
      .returning();
    
    // Check if this response should create a loveslice (if partner has also answered)
    await this.checkAndCreateLoveslice(newResponse);
    
    return newResponse;
  }

  async getResponsesByQuestionAndUser(questionId: number, userId: number): Promise<Response | undefined> {
    const [response] = await db
      .select()
      .from(responses)
      .where(and(
        eq(responses.questionId, questionId),
        eq(responses.userId, userId)
      ));
    
    return response;
  }

  async createLoveslice(loveslice: InsertLoveslice): Promise<Loveslice> {
    const [newLoveslice] = await db
      .insert(loveslices)
      .values(loveslice)
      .returning();
    
    return newLoveslice;
  }

  async getLoveslices(userId: number): Promise<any[]> {
    // This query is more complex, as we need to join multiple tables and create a custom result
    const queryResults = await db.execute(sql`
      WITH user_loveslices AS (
        SELECT 
          l.*, 
          q.content as question_content, 
          q.theme as question_theme,
          CASE WHEN l.user1_id = ${userId} THEN r1.content ELSE r2.content END as user_response_content,
          CASE WHEN l.user1_id = ${userId} THEN r2.content ELSE r1.content END as partner_response_content,
          CASE WHEN l.user1_id = ${userId} THEN u2.id ELSE u1.id END as partner_id,
          CASE WHEN l.user1_id = ${userId} THEN u2.name ELSE u1.name END as partner_name
        FROM loveslices l
        JOIN questions q ON l.question_id = q.id
        JOIN responses r1 ON l.response1_id = r1.id
        JOIN responses r2 ON l.response2_id = r2.id
        JOIN users u1 ON l.user1_id = u1.id
        JOIN users u2 ON l.user2_id = u2.id
        WHERE l.user1_id = ${userId} OR l.user2_id = ${userId}
      )
      SELECT * FROM user_loveslices
      ORDER BY created_at DESC
    `);
    
    return queryResults as any[];
  }

  async getLovesliceById(id: number): Promise<any | undefined> {
    const results = await db.execute(sql`
      SELECT 
        l.*,
        q.content as question_content,
        q.theme as question_theme,
        r1.content as response1_content,
        r2.content as response2_content,
        u1.name as user1_name,
        u2.name as user2_name
      FROM loveslices l
      JOIN questions q ON l.question_id = q.id
      JOIN responses r1 ON l.response1_id = r1.id
      JOIN responses r2 ON l.response2_id = r2.id
      JOIN users u1 ON l.user1_id = u1.id
      JOIN users u2 ON l.user2_id = u2.id
      WHERE l.id = ${id}
    `);
    
    if (results.length === 0) return undefined;
    
    const result = results[0] as any;
    return {
      ...result,
      question: {
        id: result.question_id,
        content: result.question_content,
        theme: result.question_theme
      },
      response1: {
        id: result.response1_id,
        content: result.response1_content
      },
      response2: {
        id: result.response2_id,
        content: result.response2_content
      },
      user1: {
        id: result.user1_id,
        name: result.user1_name
      },
      user2: {
        id: result.user2_id,
        name: result.user2_name
      }
    };
  }

  async updateLovesliceNote(id: number, note: string): Promise<Loveslice | undefined> {
    const [updatedLoveslice] = await db
      .update(loveslices)
      .set({ privateNote: note })
      .where(eq(loveslices.id, id))
      .returning();
    
    return updatedLoveslice;
  }

  private async checkAndCreateLoveslice(newResponse: Response): Promise<void> {
    // Get the user who created this response
    const user = await this.getUser(newResponse.userId);
    if (!user || !user.partnerId) return;
    
    // Find if partner has responded to the same question
    const partnerResponse = await this.getResponsesByQuestionAndUser(
      newResponse.questionId,
      user.partnerId
    );
    
    if (partnerResponse) {
      // Both partners have responded, create a loveslice
      const lovesliceData: InsertLoveslice = {
        questionId: newResponse.questionId,
        user1Id: user.id,
        user2Id: user.partnerId,
        response1Id: newResponse.id,
        response2Id: partnerResponse.id,
        privateNote: null,
      };
      
      await this.createLoveslice(lovesliceData);
    }
  }

  private async seedQuestionsIfNeeded() {
    // Check if we already have questions
    const existingQuestions = await db.select().from(questions).limit(1);
    if (existingQuestions.length > 0) {
      console.log("Questions already exist, skipping seed.");
      return;
    }

    console.log("Seeding questions...");
    
    // Trust theme
    await this.createQuestion({
      content: "What's one behavior that makes you feel the most secure in our relationship?",
      theme: "Trust",
    });
    await this.createQuestion({
      content: "What's one secret you've been hesitant to share with me?",
      theme: "Trust",
    });
    await this.createQuestion({
      content: "When have you felt most trusted by me?",
      theme: "Trust",
    });

    // Intimacy theme
    await this.createQuestion({
      content: "What's one way I could make you feel more loved that I'm not currently doing?",
      theme: "Intimacy",
    });
    await this.createQuestion({
      content: "What's a memory with me that you cherish the most?",
      theme: "Intimacy",
    });
    await this.createQuestion({
      content: "What physical touch makes you feel most connected to me?",
      theme: "Intimacy",
    });

    // Conflict theme
    await this.createQuestion({
      content: "What's one thing I do during disagreements that you wish I would stop?",
      theme: "Conflict",
    });
    await this.createQuestion({
      content: "What's something you wish I understood about how you handle conflict?",
      theme: "Conflict",
    });
    await this.createQuestion({
      content: "How can I better support you after we've had a disagreement?",
      theme: "Conflict",
    });

    // Dreams theme
    await this.createQuestion({
      content: "What's one dream for our future that you haven't told me about yet?",
      theme: "Dreams",
    });
    await this.createQuestion({
      content: "What's one adventure you'd love for us to experience together?",
      theme: "Dreams",
    });
    await this.createQuestion({
      content: "How do you envision our relationship evolving over the next five years?",
      theme: "Dreams",
    });

    // Play theme
    await this.createQuestion({
      content: "What activity or hobby would you like us to try together?",
      theme: "Play",
    });
    await this.createQuestion({
      content: "What's something playful or silly you'd like to see more of in our relationship?",
      theme: "Play",
    });
    await this.createQuestion({
      content: "When was the last time you felt truly carefree and joyful with me?",
      theme: "Play",
    });

    console.log("Seeding questions complete.");
  }
}

export const storage = new DatabaseStorage();